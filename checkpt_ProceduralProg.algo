
PROCEDURE dot_product(v1, v2: ARRAY_OF FLOAT, VAR Ps:FLOAT)
VAR
    i : INTEGER;
BEGIN
    Ps := 0;
    FOR i FROM 0 TO v1.length - 1 STEP 1  DO
       Ps := Ps + v1[i] * v2[i];
       // Write("Le PS de v1 et v2 est: " + Ps);
    END_FOR   
END

FUNCTION  dot_product( v1, v2: ARRAY_OF FLOAT) : FLOAT
VAR
    ps : FLOAT := 0;
    i : INTEGER;
BEGIN
    FOR i FROM 0 TO v1.length - 1 STEP step  DO
        ps := ps + v1[i] * v2[i];    
    END_FOR
    // Write("Le PS de v1 et v2 est: " + ps);
   RETURN ps ;
END

PROCEDURE Saisie(VAR v: ARRAY_OF FLOAT, n: INTEGER)
VAR
   i, j : INTEGER;
BEGIN
     FOR i FROM 0 TO 2*n - 1 STEP 1  DO
        FOR j FROM 0 TO n - 1 STEP 1  DO
            Read(v[i][j]);
        END_FOR
    END_FOR

END

// L'algorithm Main
ALGORITHM Dot_Product_Vectors
VAR
    n, i : INTEGER;    
    v : ARRAY_OF FLOAT[100][100]; 
     
BEGIN
    Read(n);
    FOR i FROM 0 TO 2*(n - 1) STEP 2  DO

        Saisie(v[i], n);
        Saisie(v[i+1], n);

        IF (dot_product(v[i], v[i+1]) = 0) THEN
       
        Writeln("Les v",i " et v",i+1" sont orthogonaux");

        ELSE

        Writeln("Les v",i " et v",i+1" ne sont pas orthogonaux");

        END_IF
    
    END_FOR
       
END

ALGORITHM Dot_Product_Vectors2
VAR
    n, i, j : INTEGER;    
    v : ARRAY_OF FLOAT[100][100]; 
     
BEGIN
    Read(n);

    FOR i FROM 0 TO 2*(n - 1) STEP 2  DO
        FOR j FROM 0 TO n - 1 STEP 1  DO
            Read(v[i][j]);  
            Read(v[i+1][j]);
        END_FOR

        IF (dot_product(v[i], v[i+1]) = 0) THEN
       
        Writeln("Les v",i " et v",i+1" sont orthogonaux");
        
        ELSE

        Writeln("Les v",i " et v",i+1" ne sont pas orthogonaux");

        END_IF
    
    END_FOR
       
END